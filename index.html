<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">
    <style type="text/css">
      mark {
	  color: black;
      }
      .box {
	  width: 150px;
	  height: 75px;
	  background-color: black;
	  color: #fff;
	  padding: 20px;
	  position: relative;
	  margin: 40px;
	  float: left;
      }

      .box.arrow-top {
	  margin-top: 40px;
      }

      .box.arrow-top:after {
	  content: " ";
	  position: absolute;
	  right: 30px;
	  top: -15px;
	  border-top: none;
	  border-right: 15px solid transparent;
	  border-left: 15px solid transparent;
	  border-bottom: 15px solid black;
      }

      .box.arrow-right:after {
	  content: " ";
	  position: absolute;
	  right: -15px;
	  top: 15px;
	  border-top: 15px solid transparent;
	  border-right: none;
	  border-left: 15px solid black;
	  border-bottom: 15px solid transparent;
      }

      .box.arrow-bottom:after {
	  content: " ";
	  position: absolute;
	  right: 30px;
	  bottom: -15px;
	  border-top: 15px solid black;
	  border-right: 15px solid transparent;
	  border-left: 15px solid transparent;
	  border-bottom: none;
      }

      .box.arrow-left:after {
	  content: " ";
	  position: absolute;
	  left: -15px;
	  top: 15px;
	  border-top: 15px solid transparent;
	  border-right: 15px solid black;
	  border-left: none;
	  border-bottom: 15px solid transparent;
      }      
    </style>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
	<section>
	  <!--ADL a thorougg introduction in name taxonomy-->
    	  <section>
	    <h5 style="font-size:32px" align="left">
		ADL: a thorough introduction in name taxonomy, customization points and use cases in the context of templates
		<br>
		<br>
		Presenter: Kostas Kyrimis
	    </h5>
	  </section>
	  
	  <!--Outline-->
	  <section>
	      <h5 style="font-size:32px" align="left">
		Outline <br>
		<ul style="font-size:18px";>
		  <li> Presenter information </li>
		  <li> History, when and why Argument Dependent Lookup(ADL)? </li>
		  <li> Name Taxonomy </li>
		  <li> Templates and ADL </li>
		  <li> Customization Points and Customization Point Objects(CPO) </li>
		  <li> Tips && discussion </li>
		</ul>
	      </h5>
	  </section>
	<!--End of outline-->
	</section>

        <!--Presenter Inforation-->
	<section>
	  <h5 style="font-size:32px" align="left">
	    Presenter Information
	  </h5>
	  <p style="font-size:18px">
	    <ul style="font-size:18px">
	      <li> Why am I here and what's the purpose of this talk? </li>
	      <li> Software Engineer at Codeplay </li>
	      <li> Working on ComputeCpp; Codeplay implementation of SYCL Khronos Group Open Standard </li>
	      <li> What is SYCL?
		<ul style="font-size:18px";>		
	          <li> Programming model that allows to program heterogeneous systems in single source C++ </li>
		</ul>
	      </li>
	      <li> How to approach me?		
		<ul style="font-size:18px";>		
  		  <li> Snowboarding, weight lifting, investing(stocks, real estate) and travelling is a good start but please feel free to reach me out about anything --
                       I am very easy going person </li>
		</ul>
	      </li>
	    </ul>
	  </p>
	</section>
	 
	<!-- History, when and why ADL-->
	<section>
	  <section>
	  <h5 style="font-size:32px" align="center">
	    History, when and why ADL
	  </h5>
	  <p style="font-size:18px" align="left">
	    We want to use the operator<< without explicitly calling it with std::operator&lt;&lt;
   					  as it brutally defeats the purpose of operator overloading
          </p>
	  
	  <pre><code class="c++" align="left" data-trim data-noescape>
	      #include &lt;iostream&gt;
	      int main() {
	        std::operator<<(std::cout, "Hello, World\n"); //Case 1
	        std::cout << "Hello, World\n";                //Case 2
	      }
	  </code></pre>
	 
	  <p style="font-size:18px" align="left">	  
	  Had we not had a language feature (ADL), line 2 of the above code would be
	  <font color="red">ill-formed</font>. Koenig Lookup was proposed for this matter
	  (it only applied to operators) and later it was “extended” – the feature that is now known
	  as ADL
	  </p>
	  </section>
	  
	  <section>
	    <p style="font-size:18px" align="left">	  
	    Q: Do we need ADL? </br>
            A: Yes, mainly for the following reasons:
            <ul style="font-size:18px">
	      <li> A call to an operator would need to be explicit(i.e. it would look like a normal function  
		call) which defeats the purpose of operator overloading all together </li>
	      <li> Unlike Java, C++ has non member functions and sometimes these functions are 
		part of a type’s interface. For a class object, we always know that the entity we refer
		to has a set of member functions which are defined in the encolsing scope of that
		particular class type. Therefore, we need a mechanism for associating non member
		functions that are a part of the type’s interface Remember Herb Sutter’s and Andrei 
		Alexandrescu interface principle which essential comes down to two items:
		<ul style="font-size:18px">
		<li> 57. Keep a type and its nonmember function interface in the same namespace.</li>
		<li> 58. Keep types and functions in separate namespaces unless they’re specifically intended to work together. </li>
		</ul>
	      <li> Templates. As we shall show, without ADL the usability of templates is greatly		
		reduced. On the contrary, uncostrained templates can be the source of weird errors(ADL bites). </li>
	    </ul>
	    </p>
	  </section>
	</section>

	<!-- Name Taxonomy-->
	  <section>
	    <section>
	      <h5 style="font-size:32px" align="center">
		Name Taxonomy
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> Name taxonomy is important because it allows the programmer to reason about their code and make
		    non intuitive cases clear and easy to understand/argue about </li>
		  <li> Essentially, when the compiler sees a name, it must look it up somehow. The process of looking
		    up that name depends on the name taxonomy that the entity referred belongs </li>
		  <li> The standard defines name taxonomy in a non intutive way. But we can’t rely on the standard for
		    a day to day programming. We can hopefully get away for the most cases by understanding the following 4
		    categories </li> 
		  <li> A name can be one of the four(or a mix): qualified, unqualified, dependent and non-dependent </li>
		</ul>
	      </p>
	    </section>

	    <section>
	      <h5 style="font-size:32px" align="center">
		Name lookup in a nutshell
	      </h5>	      
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> Name taxonomy is important because it allows the programmer to reason about their code and make
		    non intuitive cases clear and easy to understand/argue about </li>
		  <li> Essentially, when the compiler sees a name, it must look it up somehow. The process of looking
		    up that name depends on the name taxonomy that the entity referred belongs </li>
		  <li> The standard defines name taxonomy in a non intutive way. But we can’t rely on the standard for
		    a day to day programming. We can hopefully get away for the most cases by understanding the following 4
		    categories </li> 
		  <li> A name can be one of the four(or a mix): qualified, unqualified, dependent non-dependent </li>
		</ul>
	      </p>
	    </section>	    

	    <section>
	      <h5 style="font-size:32px" align="center">
		How does the compiler process a function call?
	      </h5>
	      <div class="box arrow-right">
		<p style="font-size:18px" align="left"> 1. Name Lookup </p>
	      </div>
	      <div class="box">
		<p style="font-size:18px" align="left"> 2. Overload resolution </p>
	      </div>
	      <br> <br> <br><br>
	      <div class="box arrow-right">
		<p style="font-size:18px" align="left"> Name Lookup </p>
	      </div>
	      <div class="box arrow-right">
		<p style="font-size:18px" align="left"> Qualified </p>
	      </div>
	      <div class="box">
		<p style="font-size:18px" align="left"> Template? Dependent or Nondependent </p>
	      </div>	      	      
	      <br> <br> <br><br>
	      <div class="box arrow-right">
		<p style="font-size:18px" align="left"> Name Lookup </p>
	      </div>
	      <div class="box arrow-right">
		<p style="font-size:18px" align="left"> unqualified </p>
	      </div>
	      <div class="box">
		<p style="font-size:18px" align="left"> Template? Dependent or Nondependent </p>
	      </div>	      	      
	    </section>

	    <section>
	      <h5 style="font-size:32px" align="center">
		Qualified names 
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> A qualified name is when an entity is referred to and prefixed with one of the following:
		    <ul style="font-size:18px">
		      <li> Scope resolution operator (scope::name) </li>
		      <li> Member access operator (obj.member) and (obj&rarr;member) </li>
		    </ul> </li>
		  <li> The lookup scope is the scope implied by the qualified construct. For example: </li>
		</ul>
	      </p>
	      <pre><code class="c++" align="left" data-trim data-noescape>
		int foo;
		
		struct  X {
		  void f() { };
		}
		  
		void f(X a) {
		  a.f();
		  X::foo = 45;  //Error no foo in X
		}
	      </code></pre>
	    </section>
	    
	    <section>
	      <h5 style="font-size:32px" align="center">
		Unqualified names
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> Unqualified names are looked up in subsequent enclosing scopes. This is called ordinary lookup. In addition
		    to that, unqualified names “sometimes” undergo an extra step, the argument dependent lookup </li>
		  <li> It's a two step process where the second step is optional </li> 
		  <li> Fortunately, it's easy to explain this with two sets: Let U be the set produced by the unqualified lookup
		    and A be the set produced by the argument dependent lookup. If U contains the name of:
		    <ul style="font-size:18px">
		      <li> Declaration of a class member </li>
		      <li> A block scope function declaration </li>
		    </ul>
		    then A is empty. Otherwise, the set of declarations found by the lookup is the union of U and A. </li>
		</ul>
	      </p>
	    </section>	      

	    <section>
	      <h5 style="font-size:32px" align="center">
		Step 1: ordinary lookup 
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> Perform the ordinary lookup by looking up in subsequent enclosing scopes. For example: </li>
		</ul>
	      </p>
	      <pre><code class="c++" align="left" data-trim data-noescape>
		int foo;
		struct  X {
		  int foo() { };

		  void f() {
		    foo(); //Refers to X::foo()
		  };
		}

		void my_fun() { };
		void g(X a) {
		  foo = 4;  //Ok assigns to ::foo
		  f();      //Diagnostic: no f found
		  my_fun(); //ok ::my_fun() called
		}
	      </code></pre>
	    </section>	    

	    <section>
	      <h5 style="font-size:32px" align="center">
		Step 2: ADL
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> For each argument type T in the function call there are two sets (each of size zero or more)
		    <ul style="font-size:18px">
		      <li> Set N (associated namespaces) </li>
		      <li> Set E (associated entities) </li>
		    </ul>
		    typedefs and using-declarations do not! contribute to this set  </li>
		  <li> There are 7 ADL rules you need to remember </li>
		</ul>
	      </p>
	    </section>
	    
	    <section> 
	      <h5 style="font-size:32px" align="center">
		Picking up the right name
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> Let U be the set produced by (U)nqualified lookup and A the set produced by (A)rgument dependent lookup
		If U contains:
		<ul style="font-size:18px">
		  <li> A declaration of a class member </li>
		  <li> A block scope function declaration </li>
		  <li> A declaration that is neither a function nor a function template </li>
		</ul>
		Then A is empty and the lookup does not proceed to step 2. </li>
		<ul>
	      </p>
	      </section>

	    <section> 
	      <h5 style="font-size:32px" align="center">
		The 7 rules of ADL
	      </h5>
	      <p style="font-size:18px" align="left">
		<ol style="font-size:18px">
		  <li> T is a fundamental type </li>
		  <li> T is a class type  </li>
		  <li> T is an enumeration type </li>
		  <li> T is a pointer to Y or an array of U </li>
		  <li> T is a function type </li>
		  <li> T is a pointer to a member function </li>
		  <li> T is a pointer to a data member of a class X </li>
		</ol>
	      </p>
	    </section>		

	    <section>
	      <h5 style="font-size:32px" align="center">
		1. T is a fundamental type
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> The set N, E are empty </li>
		  <li> For example: </li>
		</ul>
	      </p>
	      <pre><code class="c++" align="left" data-trim data-noescape>
		namespace N {
		  void f(int);
		}
		  
		int main() {
		  f(1); //Diagnostic, no f found
		}
	      </code></pre>
	    </section>	    

	    <section>
	      <h5 style="font-size:32px" align="center">
		2. T is of a class type
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> E is {class itself, the class which is a member to(if any) and any indirect or direct base classes} </li>
		  <li >N is {innermost enclosing namespaces of its associated entities} </li>
		</ul>
	      </p>
	      <pre><code class="c++" align="left" data-trim data-noescape>
		namespace L {
		  struct lib_type;
		  void f(lib_type t);
		}

		namespace U {
		  struct user_type : public L::lib_type { };
		  void f(L::lib_type t) ;
		}
		  
		int main() {
		  U::user_type t;
		  f(t); //Diagnostic ambiguous
		}
	      </code></pre>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> E { lib_type, user_type } and N { L, U } </li>
		  <li> Step 1. Ordinary lookup finds nothing X is empty </li>
		  <li> Step 2. ADL finds { L::f(), U::f() } </li>
		  <li> Therefore, it’s ambiguous by the overload resolution!</li>
		</ul>
	      </p>
	    </section>	    
	  <!--This closes name taxonomy -->
	  </section>

	  <!-- Templates and ADL -->
	  <section>
	    <section>
	      <h5 style="font-size:32px" align="center">
		Templates and ADL
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> A name can be dependent or nondependent. A name is a dependent name if it depends on a template
		    paramater. </li>
		  <li> Which of the following using declarations are type dependent? </li>
		</ul>		
	      </p>
	      <pre><code class="c++" align="left" data-trim data-noescape>
		#include&lt;vector&gt;

		template&lt;typename T&gt;
		struct foo {
		  using it = typename std::vector&lt;T&gt;::iterator;
   		}

		void foo() {
		  using T = int;
		  using it = std::vector&lt;T&gt;::iterator;
		}
	      </code></pre>
	    </section>

	    <section>
	      <h5 style="font-size:32px" align="center">
		Two phase lookup
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> Non dependent names (unqualified or qualified) are looked up with the rules we described </li> 
		  <li> Unqualified dependent names are looked up using the ordinary lookup rules but they are not complete
		    until the point of instantiation(POI) of the template. When the template is instantiated, unqualified
		    dependent names undergo an ADL. For example: </li>
		</ul>		
	      </p>
	      <pre><code class="c++" align="left" data-trim data-noescape>
		namespace N {
		  struct foo {};

		  template&lt;typename T&gt;
		  void f(foo t) {}
		}

		template&lt;typename T&gt;
		void g(foo t) {}

		void h() {
		  f&lt;int&gt;(N::foo{}); //Is this valid?
		  g&lt;int&gt;(N::foo{}); //Is this valid?
		}
	      </code></pre>
	    </section>

	    <section>
	      <h5 style="font-size:32px" align="center">
		Friends and ADL 
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> In 1994, it used to be the case that in-class friend
		    definitions were injected into the outerclosing namespace,
		    a process known as friend-name-injection which was later
		    replaced by ADL </li>
		  <li> Dependent friends can be found by ADL. For example: </li> 
		</ul>		
	      </p>
	      <pre><code class="c++" align="left" data-trim data-noescape>
		namespace N {
		  template&lt;typename T&gt;
		  class foo {
		   public:
		     friend void f(foo&lt;T&gt; v) { } 
		  };
		}

		void h() {
		  N::foo&lt;int&gt; obj;
		  f(obj);
		}
			
		int main() {
		  h();
		}
	      </code></pre>
	    </section>

	    <section>
	      <h5 style="font-size:32px" align="center">
		ADL bites 1: Unconstrained Templates
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> What will the following code call? </li>
		  <li> Which canditates are fed to the overload resolution? </li>
		  <li> Does this code look familiar? </li>
		</ul>		
	      </p>
	      <pre><code class="c++" align="left" data-trim data-noescape>
		#include &lt;shared_ptr&gt;
		#include &lt;iostream&gt;

		namespace lib {
		  struct cont { };
		}

		namespace user {
		  using my_type = std::shared_pointer<lib::cont>;

		  void tie(my_type const& t1, my_type const& t2) {
		    std::cout << "ADL please pick me!\n";
		  }

		  void oups() {
		    auto t1 = std::make_shared<lib::cont>();
		    auto t2 = std::make_shared<lib::cont>();
		    tie(t1, t2);
		  }
		}
			
		int main() {
		  user::oups();
		}
	      </code></pre>	
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> Ordinary lookup finds user::tie. O is {user::tie} </li>
		  <li> ADL finds std::tie. A is {std::tie} </li>
		  <li> Overload resolution resolves std::tie as a better match </li>
		</ul>		
	      </p>      
	    </section>		    

	    <section>
	      <h5 style="font-size:32px" align="center">
		ADL bites 2: iterators and algorithms 
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> Iterators is the glue between algorithms and containers </li>
		  <li> It allows the user to treat algorithms as sequencies, without worrying
		    about the underline implementation. But there is more! </li>
		  <li> The following attempt might lead to surprises </li>
		</ul>		
	      </p>
	      <pre><code class="c++" align="left" data-trim data-noescape>
		 #include &lt;algorithm&gt;
		 #include &lt;array&gt;		    
		 #include &lt;vector&gt;

		 int main() {
		   int a[] = {1, 2, 3, 4};
		   auto arr = std::array&lt;int, 4&gt;{ {1, 2, 3, 4} };
		   auto v = std::vector&lt;int&gt;{ {1, 2, 3, 4} };

		   using std::begin;
		   using std::end;

		   constexpr int key = 4;

		   find(a, a + 4, key);              //1
		   find(begin(arr), end(arr), key);  //2
		   find(begin(v), end(v), key);      //3
		 }
	      </code></pre>
	    </section>

	    <section>
	      <h5 style="font-size:32px" align="center">
		ADL bites 3: unspecified behaviour
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> Iterators is the glue between algorithms and containers </li>
		  <li> It allows the user to treat algorithms as sequencies, without worrying
		    about the underline implementation. But there is more! </li>
		  <li> The following attempt might lead to surprises </li>
		</ul>		
	      </p>
	      <pre><code class="c++" align="left" data-trim data-noescape>

	      </code></pre>
	    </section>

	    <section>
	      <h5 style="font-size:32px" align="center">
		Guidelines:
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> When using iterators with algorithms,
		    always qualify the call with std</li>
		  <li> </li>
		  <li> </li>
		</ul>		
	      </p>
	    </section>	    
	    
	  <!-- This closes templates and ADL -->
	  </section>

	  <section> 
	    <section>
	      <h5 style="font-size:32px" align="center">
		When generic code doesn't quite cut it: customization Points and where to find them
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> A library is unaware of a user defined type and therefore, even
		    though it can provide a sensible generic implementation for an 
		    operation, it can't really know how to optimize it on the users behalf.
		    For this reason a customization point in a library is a function that the
		    user can overload with their own implementation. Then, a library function will 
		    call the customization point function unqualified and trigger ADL. </li>
		   <li> Essentially, customization points allow the library
		    to do something sensible in the generic case while delegating the behaviour to the user
		    when needed. </li>
		</ul>		
	      </p>
	    </section>

	    <section>
	      <h5 style="font-size:32px" align="center">
		When customization points don't quite cut it: enter customization point objects(std::ranges)!
	      </h5>
	      <p style="font-size:18px" align="left">
		<ul style="font-size:18px">
		  <li> As we showed, there are numerous problems with customization points. Also we showed how
		    std::swap() can be problematic. </li>
		  <li> Customization point objects wrap around the function in lambda to disable ADL <li>
		</ul>		
	      </p>
	    </section>	    
	  </section>
	  
      </div>
    </div>

    <script src="js/reveal.js"></script>
    
    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
	  dependencies: [
	      { src: 'plugin/markdown/marked.js' },
	      { src: 'plugin/markdown/markdown.js' },
	      { src: 'plugin/notes/notes.js', async: true },
	      { src: 'plugin/highlight/highlight.js', async: true }
	  ],
          slideNumber: true
	  
      });
    </script>
  </body>
</html>
